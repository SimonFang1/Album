/*************************************************************************************************************
 * 文件名:	system.c
 * 功能:		S3C6410相关系统函数
 * 作者:		cp1300@139.com
 * 创建时间:	2012年3月4日11:25
 * 最后修改时间:2012年3月4日
 * 详细:		2012年3月5日17:00 添加VIC相关函数
*************************************************************************************************************/
#include "system.h"


// /*************************************************************************************************************************
// *函数        :	void SetEINT_TriggerMode(u8 EINT0_N,u8 Trigger)
// *功能        :	设置外部中断组0触发模式
// *参数        :	EINT0_N:中断源的编号(见:中断组0编号定义);Trigger:触发模式(EXT_LowLevel:低电平触发;EXT_HighLevel:高电平触发;
// 					EXT_NegEdge:下降沿触发;EXT_PosEdge:上升沿触发;EXT_Edge:边沿触发)
// *返回        :	无
// *依赖        :	底层宏定义
// *作者        :	cp1300@139.com
// *时间        :	20120304
// *最后修改时间:	20120304
// *说明        :	编号 GPN0--->GPN15  GPL8--->GPL14  GPM0--->GPM4,中断设置必须两个两个一起
// *************************************************************************************************************************/
// void SetEINT0_TriggerMode(vu8 EINT0_N,vu8 Trigger)
// {	
// 	if(EINT0_N & 0x80) //EINT0CON1
// 	{
// 		EINT0_N -= 0x80;//减去标记
// 		rEINT0CON1 &= ~(7 << EINT0_N);//清楚原来的设置
// 		rEINT0CON1 |= Trigger << EINT0_N;
// 	}
// 	else	//EINT0CON0
// 	{
// 		rEINT0CON0 &= ~(7 << EINT0_N);//清楚原来的设置
// 		rEINT0CON0 |= Trigger << EINT0_N;
// 	}
// }



// /*************************************************************************************************************************
// *函数        :	void Set_GateClk(u8 HCLK_DIV,FunctionalState Enable)
// *功能        :  CLK时钟门控设置(HCLK,PCLK,SCLK)
// *参数        :  CLK_DIV:外设(见:CLK门控时钟定义);Enable = ENABLE,1使能;=DISABLE,0失能
// *返回        :  无
// *依赖        :	底层宏定义
// *作者        :  cp1300@139.com
// *时间        :	20120305
// *最后修改时间: 	20121005
// *说明        :  PCLK_GATE添加标识0x40,SCLK_GATE添加标示0x80;
// *************************************************************************************************************************/

// void Set_GateClk(vu8 CLK_DIV,FunctionalState Enable)
// {
// 	vu32 *P = &rHCLK_GATE;
	
// 	if(CLK_DIV & 0x80)		//SCLK
// 	{
// 		P = &rSCLK_GATE;
// 		CLK_DIV -= 0x80;	//去掉标示
// 	}
// 	else if(CLK_DIV & 0x40)	//PCLK
// 	{
// 		P = &rPCLK_GATE;
// 		CLK_DIV -= 0x40;	//去掉标示
// 	}
// 	if(Enable == ENABLE)	//使能
// 		*P |= 1 << CLK_DIV;
// 	else		//失能
// 		*P &= ~(1 << CLK_DIV);
// }



// /*************************************************************************************************************************
// *函数        :	void Set_INTtoIRQ(u8 INT_N)
// *功能        :  设置一个中断为IRQ
// *参数        :  INT_N:中断编号(见:中断源编号定义);
// *返回        :  无
// *依赖        :	底层宏定义
// *作者        :  cp1300@139.com
// *时间        :	20120305
// *最后修改时间: 	20120305
// *说明        :  设置一个中断为普通中断模式
// *************************************************************************************************************************/
// void Set_INTtoIRQ(vu8 INT_N)
// {
// 	if(INT_N > 31)	//VIC1
// 	{
// 		INT_N -= 32;
// 		VIC1->INTSELECT &= ~(1 << INT_N);
// 	}
// 	else			//VIC0
// 		VIC0->INTSELECT &= ~(1 << INT_N);
// }


// /*************************************************************************************************************************
// *函数        :	void Set_INTtoFIQ(u8 INT_N)
// *功能        :  设置一个中断为FIQ
// *参数        :  INT_N:中断编号(见:中断源编号定义);
// *返回        :  无
// *依赖        :	底层宏定义
// *作者        :  cp1300@139.com
// *时间        :	20120305
// *最后修改时间: 	20120305
// *说明        :  设置一个中断为快速中断模式
// *************************************************************************************************************************/
// void Set_INTtoFIQ(vu8 INT_N)
// {
// 	if(INT_N > 31)	//VIC1
// 	{
// 		INT_N -= 32;
// 		VIC1->INTSELECT |= (1 << INT_N);
// 	}
// 	else			//VIC0
// 		VIC0->INTSELECT |= (1 << INT_N);
// }


// ************************************************************************************************************************
// *函数        :	void Set_IntEnable(u8 INT_N,FunctionalState EnInt)
// *功能        :  开启或关闭一个VIC中断
// *参数        :  INT_N:中断编号(见:中断源编号定义),
// * 			EnInt = ENABLE,1使能;=DISABLE,0失能;
// *返回        :  无
// *依赖        :	底层宏定义
// *作者        :  cp1300@139.com
// *时间        :	20120305
// *最后修改时间: 	20120305
// *说明        :  使能或失能VIC0,VIC1的一个中断
// ************************************************************************************************************************
void Set_IntEnable(vu8 INT_N,FunctionalState EnInt)
{
	VICx_TypeDef *P = VIC0;
	
	if(INT_N > 31)	//VIC1
	{
		INT_N -= 32;
		P = VIC1;
	} 
	if(EnInt == ENABLE) //使能中断
		P->INTENABLE = 1 << INT_N;	//写1使能中断,写0无影响
	else		//取消中断
		P->INTENCLEAR = 1 << INT_N;	//写1清除中断使能,写0无影响
}


/*************************************************************************************************************************
*函数        :	u8 Get_IntEnable(vu8 INT_N)
*功能        :  获取一个中断屏蔽状态
*参数        :  中断编号
*返回        :  1:该中断失能,0:该中断失能
*依赖        :	底层宏定义
*作者        :  cp1300@139.com
*时间        :	20120524
*最后修改时间: 	20120524
*说明        :  获取一个中断屏蔽状态
*************************************************************************************************************************/
u8 Get_IntEnable(vu8 INT_N)
{
	VICx_TypeDef *P = VIC0;
	
	if(INT_N > 31)	//VIC1
	{
		INT_N -= 32;
		P = VIC1;
	} 
	if(P->INTENABLE & (1 << INT_N)) //该中断使能
		return 1;
	else 
		return 0;
}


// /*************************************************************************************************************************
// *函数        :	void Set_SoftInt(u8 INT_N,u8 ENABLE)
// *功能        :  开启或关闭一个软件中断
// *参数        :  INT_N:中断编号(见:中断源编号定义),ENABLE = Enable,1使能;=Disable,0失能;
// *返回        :  无
// *依赖        :	底层宏定义
// *作者        :  cp1300@139.com
// *时间        :	20120305
// *最后修改时间: 	20120305
// *说明        :  使能或失能VIC0,VIC1的一个软件中断
// *************************************************************************************************************************/
// void Set_SoftInt(vu8 INT_N,vu8 ENABLE)
// {
// 	VICx_TypeDef *P = VIC0;
	
// 	if(INT_N > 31)	//VIC1
// 	{
// 		INT_N -= 32;
// 		P = VIC1;
// 	} 
// 	if(ENABLE) //使能中断
// 		P->SOFTINT = 1 << INT_N;	//写1使能软件中断,写0无影响
// 	else		//取消中断
// 		P->SOFTINTCLEAR = 1 << INT_N;	//写1清除软件中断使能,写0无影响
// }



// /*************************************************************************************************************************
// *函数        :	void Set_IsrAddr(u8 INT_N,vu32 IsrAdd)
// *功能        :  设置中断矢量入口
// *参数        :  INT_N:中断编号(见:中断源编号定义),IsrAdd:中断服务程序指针;
// *返回        :  无
// *依赖        :	底层宏定义
// *作者        :  cp1300@139.com
// *时间        :	20120305
// *最后修改时间: 	20120311
// *说明        :  设置矢量地址寄存器
// *************************************************************************************************************************/
// void Set_IsrAddr(vu8 INT_N,vu32 IsrAdd)
// {
// 	VICx_TypeDef *P = VIC0;
	
// 	if(INT_N > 31)	//VIC1
// 	{
// 		INT_N -= 32;
// 		P = VIC1;
// 	}
// 	P->VECTADDR[INT_N] = IsrAdd;//将中断服务程序入口地址写入矢量地址寄存器
// }


// /*************************************************************************************************************************
// *函数        :	void Set_VectorPriority(u8 INT_N,u8 Priority)
// *功能        :  设置矢量优先级
// *参数        :  INT_N:中断编号(见:中断源编号定义),Priority:优先级0-15;
// *返回        :  无
// *依赖        :	底层宏定义
// *作者        :  cp1300@139.com
// *时间        :	20120305
// *最后修改时间: 	20120305
// *说明        :  优先级为0-15,值越大优先级越高,15最高,0最低;
// *************************************************************************************************************************/
// void Set_VectorPriority(vu8 INT_N,vu8 Priority)
// {
// 	VICx_TypeDef *P = VIC0;
	
// 	if(INT_N > 31)	//VIC1
// 	{
// 		INT_N -= 32;
// 		P = VIC1;
// 	}
// 	P->VECTRPRIORITY[INT_N] = Priority;//将中断优先级写入寄存器
// }





/*************************************************************************************************************************
*函数        :	u32 Get_PLLCLK(int pllreg)
*功能        :  获取PLL时钟频率
*参数        :  pllreg : PLL选择
					APLL 	0	//ARM内核时钟PLL
					MPLL 	1	//主时钟PLL
					EPLL 	2	//外设时钟PLL
*返回        :  频率,HZ
*依赖        :	底层宏定义
*作者        :  cp1300@139.com
*时间        :	20120526
*最后修改时间: 	20120526
*说明        :  无
*************************************************************************************************************************/
// u32 Get_PLLCLK(u8 pllreg)
// {
// 	u32 r = 0, m, p, s;

// 	if (pllreg == APLL)
// 		r = rAPLL_CON;
// 	else if (pllreg == MPLL)
// 		r = rMPLL_CON;
// 	else if (pllreg == EPLL)
// 		r = rEPLL_CON0;

// 	m = (r>>16) & 0x3ff;
// 	p = (r>>8) & 0x3f;
// 	s = r & 0x7;

// 	return (m * (SYSTEM_MAIN_CLK_IN / (p * (1 << s))));
// }


/*************************************************************************************************************************
*函数        :	u32 Get_FCLK(void)
*功能        :  获取FCLK时钟频率
*参数        :  无
*返回        :  频率,HZ
*依赖        :	底层宏定义
*作者        :  cp1300@139.com
*时间        :	20120526
*最后修改时间: 	20120526
*说明        :  无
*************************************************************************************************************************/
// u32 Get_FCLK(void)
// {
// 	return (Get_PLLCLK(APLL));
// }



/*************************************************************************************************************************
*函数        :	u32 Get_PCLK(void)
*功能        :  获取PCLK时钟频率
*参数        :  无
*返回        :  频率,HZ
*依赖        :	底层宏定义
*作者        :  cp1300@139.com
*时间        :	20120526
*最后修改时间: 	20120526
*说明        :  无
*************************************************************************************************************************/
// u32 Get_PCLK(void)
// {
// 	u32 fclk;
// 	u32 hclkx2_div = ((rCLK_DIV0 >> 9) & 0x7) + 1;
// 	u32 pre_div = ((rCLK_DIV0 >> 12) & 0xf) + 1;

// 	if(rOTHERS & 0x80)
// 		fclk = Get_FCLK();		// SYNC Mode
// 	else
// 		fclk = Get_PLLCLK(MPLL);	// ASYNC Mode

// 	return fclk/(hclkx2_div * pre_div);
// }

